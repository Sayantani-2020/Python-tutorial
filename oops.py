# -*- coding: utf-8 -*-
"""OOPs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X7WTXCMEJrp9cQr31HYLTklZ-9WB45a7

Topic Covered: class,object,constructor,inheritance(method and constructor),private,protected,public accessfier,abstraction,nested class
Polymorphism( method overriding,operator overloading)
method overloading not there.
static method,class method,abrstract method,interface
"""

class A:
  pass # keyword

#obj = A()
#print(type(obj))

class A:
    age=10
    print(age)

class A:
    age=10
    print(age)
obj = A()
obj2 =A()
#print(id(obj))
#print(id(obj2))

class A:
    def __init__(self): # without creating object init method will not work,Default constructor
      age=10
      print(age)
obj = A()
#obj2 =A()
#print(id(obj))
#print(id(obj2))

class A:
    age=10 #class attribute
    #print(age)
obj = A()
print(obj.age)
print(A.age)

class A:
    def fun(self):
      name ="Ravi"
      print(name)
obj = A()
obj.fun()

class A:
    age=10
    def fun(self):
      name ="Ravi"
      print(name +"\n"+ str(self.age))
obj = A()
obj.fun()

class A:
    age=10
    def fun(self,name):
      print(name +"\n"+ str(self.age))
obj = A()
obj.fun("Ravi")
obj2 = A()
obj2.fun("Raka")

class A:
    def fun(self,name,age,country):
      print("My name is " + name + 'and age is '+ str(age) + " Iam from " + country)
obj = A()
obj.fun('Devi',32,'India') #passing values through function

class A:
    def __init__(self,name,age,country): #Parameterized Constructor
      print("My name is " + name + ' and age is '+str(age)  + " Iam from " + country)

obj = A('Devi',32,'India') # passing value through class

class A:
    def __init__(self,name,age,country):
      print("My name is " + name + ' and my age is '+str(age)  + " Iam from " + country) #instance variable
    def fun(self,name,age,country):
      print(name,age,country)

obj = A('Devi',32,'India')
obj.fun('Devi',32,'India') # same parameters are passing throgh fun,if not error occured

class A:
    def __init__(self,name,age,country):

      self.name = name #you can access these variables throughout the object's lifetime using self.name. This makes them accessible within other methods of the class.
      self.age = age
      self.country = country
      #print("My name is " + self.name + 'and age is '+ str(self.age) + " Iam from " + self.country)

    def fun(self):
      print("My name is " + self.name + ' and my age is '+ str(self.age) + " Iam from " + self.country)

obj = A('Ayush',32,'India')
obj2 = A('Keshav',34,'India')
obj.fun()
obj2.fun()

class A:
  def __init__(self):
    print("Python PRogramming")
  def __init__(self):
    print("Python Learning")

A()

#create account class with 2 attribute balance and account no,
# Create methods fro debit,credit,printing balance,ASSIGNMENT
class Atm:
  def __init__(self):
    self.pin =''
    self.balance = 0
    self.menu()
  def menu(self):
    user_input = input("""How do you like to proceed?
    1.Enter 1 to create pin
    2.Enter 2 to deposit
    3.Enter 3 to withdraw
    4.Enter 4 to check balance
    5.Enter 5 to exit\n""")
    if user_input == "1":
      self.create_pin()
      #print("Create Pin")
    elif user_input == "2":
      self.deposit()
      #print("Deposited")
    elif user_input == "3":
      self.withdraw()
      #print("Withdrawl")
    elif user_input == "4":
      self.check_balance()
      #print("check_balance")
    else:
      print("Exit")

  def create_pin(self):
    self.pin = input("Enter your pin:")
    print("pin set successfully")
    self.menu()

  def deposit(self):
    temp = input("Enter your pin:")
    if temp == self.pin:
      amt = int(input("Enter the Amount you want to deposit"))
      self.balance = self.balance + amt
      print("Deposited")
    else:
      print("invalid pin")
    self.menu()

  def withdraw(self):
    temp = input("Enter your pin:")
    if temp == self.pin:
      amt = int(input("Enter the Amount you want to Withdrawl"))
      if amt < self.balance:
        self.balance = self.balance - amt
        print("Withdrawl Successfully")
      else:
         print("Insufficient Fund")
    else:
      print("invalid pin")
    self.menu()

  def check_balance(self):
    temp = input("Enter your pin: ")
    if temp == self.pin:
      print(self.balance)
    else: print("invalid pin")
    self.menu()

Atm()

class Fraction:
  def __init__(self,n,d):
    self.n = n
    self.d = d
  def __str__(self):
      return "{}/{}".format(self.n,self.d)

obj = Fraction(2,3)
print(obj)

class Fraction:
  def __init__(self,n,d):
    self.n = n
    self.d = d
  def __str__(self):
      return "{}/{}".format(self.n,self.d)
  def __add__(self,other):
    temp_num = self.n * other.n + self. d * self.n
    temp_den = self.d * other.d
    return "{}/{}".format(temp_num,temp_den)

X = Fraction(2,3)
print(X)
Y =Fraction(3,2)
print(Y)
print(X+Y)

class A: #public,protected,private variable can be accessed in the same class
  a=10 #public
  _b=20 #protected,The members of a class that are declared protected are only accessible to a class(child) derived from it.
  __c=30 #private
  print(a,_b,__c)
  def Add(self):
    self.__c= self.a + self._b
    print("Addition",self.__c)

class A: #public,protected,private variable can be accessed in the same class
  a=10 #public
  _b=20 #protected
  __c=30 #private
  #print(a,_b,__c)
  def Add(self):
    self.__c= self.a + self._b
obj = A()
print(obj.a)
print(obj._b)
print(A.__c)  #value can not be accessed out side of the class
print(obj.__c)

class A: #private variable can not be accessed in the child class also,only same class
  a=10 #public
  _b=20 #protected
  __c=30 #private
  #print(a,_b,__c)
class B(A):
  def show(self):
    print(self.a)
    print(self._b)
    print(self.__c)
obj = B()
obj.show()

# we can conceptually make private attribut/mathod,,,
class Person:
  _name ="Anonymous" # protected attribute
  __roll ="10"    # private
  def __hello(self): #private method
    print("Hello")
  def welcome(self):
    return ("Welcome" +"\t" + self._name)
    self.__hello()

p1 = Person()
#print(p1.welcome())
print(p1._name)
#print(p1.__hello())

## outer class
class Outer:

    ## inner class
    class Inner:
        pass

        ## multilevel inner class
        class InnerInner:
            pass

    ## another inner class
    class _Inner:
        pass

    ## ...

    pass

class Outer:
    """Outer Class"""

    def __init__(self):
        ## Instantiating the 'Inner' class
        self.inner = self.Inner()
        ## Instantiating the '_Inner' class
        self._inner = self._Inner()

    def show_classes(self):
        print("This is Outer class")
        print(inner)
        print(_inner)

    class Inner:
        """First Inner Class"""

        def inner_display(self, msg):
            print("This is Inner class")
            print(msg)

    class _Inner:
        """Second Inner Class"""

        def inner_display(self, msg):
            print("This is _Inner class")
            print(msg)

    ## ...accessing the class below code

## instantiating the classes

## 'Outer' class
outer = Outer()
## 'Inner' class
inner = outer.Inner() ## inner = outer.inner or inner = Outer().Inner()
## '_Inner' class
_inner = outer._Inner() ## _inner = outer._outer or _inner = Outer()._Inner()

## calling the methods
outer.show_classes()

print()

## 'Inner' class
inner.inner_display("Just Print It!")

print()

## '_Inner' class
_inner.inner_display("Just Show It!")

"""Inheritance --> single,multilevel,multiple,hierchical"""

class Father:   #Single level
  def land(self):
    print("Father has 20 Cr property")
class child(Father):
  def car(self):
    print("child has 50lakh worth car")
son = child()
son.land()
son.car()
father =Father()
father.land()
#father.car() Parent class can not inherit child class

"""Multilevel inheritance"""

class Father:
  def land(self):
    print("Father has 20 Cr property")
class Child(Father):
  def car(self):
    print("child has 50lakh worth car")
class Grandchild(Child):
  def bike(self):
    print("grandchild has 6 lakh worth bike")

son = Child()
son.land()
son.car()
g_child =Grandchild()
g_child.car()
g_child.land()

"""Multiple Inheritance"""

class Father:
  def land(self):
    print("Father has 20 Cr property")

class Mother:
  def gold(self):
    print("Mother has 10 Cr worth gold")

class Child(Father,Mother):
  def car(self):
    print("child has 50lakh worth car")

son = Child()
son.gold()
son.land()

# Hierarchical inheritance is a type of inheritance in which multiple classes inherit from a single superclass. Father --->son,daughter
class Father:
  def land(self):
    print("Father has 20 Cr property")
class Son(Father):
  def car(self):
    print("child has 50lakh worth car")
class Daughter(Father):
  def car(self):
    print("child has 50lakh worth car")

son = Son()
son.land()
daughter = Daughter()
daughter.land()

"""Abstraction is used to hide internal functionality of function from the user,users know what the func does,but donts know how it does.
abstraction--> by default there is no abstraction in python.
ABC module,@abstractmethod

What is an Abstract class?
It contains one or more abstract method.
A method that has a declaration but no implementation is said to be abstract.
Python does not come with any abstract classes by default. Python has a module called ABC that serves as the foundation for building Abstract Base Classes (ABC).
"""

from abc import ABC,abstractmethod
class Shape(ABC):
  @abstractmethod
  def show(self):  #abstract method,no implementation,
    pass

class Rectangle(Shape):
 def show(self):
    print("Rectangle has 4 equal sides")

class Square(Shape):
  def __init__(self,s):
    self.s = s
  def show(self):
    print("Square has 4 equal sides")
    return self.s * self.s


#cant create obj for Shape class, abstraction
obj=Square(2)
obj.show()

from abc import ABC,abstractmethod
class Shape(ABC):
  @abstractmethod
  def show(self):
    pass

class Rectangle(Shape):
  @abstractmethod
  def area(self):
    pass

class Square(Rectangle):
  def show(self):
    print("Square has 4 equal sides")
  def area(self):
    print("Square area")


obj=Square()
obj.show()
obj.area()

"""Method Overriding"""

class Phone:
  def __init__(self,price,brand,camera):
    print("parent class constructor called")
    self.price = price
    self.brand = brand
    self.camera = camera
  def buy(self):
    print("Buying a phone")
class Smartphn(Phone):
  def buy(self):
    print("Buying a smart phn")

s = Smartphn(200000,"Apple","16")
s.buy()



#COnstructor Inheritance
class Father:
  def __init__(self):
    print("father class constructor")
  def land(self):
      print("Father has 20 cr property")
class Mother:
  def __init__(self):
      print("Mother class constructor")
  def gold(self):
     print("Mother has 10 cr property")

class Child(Mother,Father):
  #def __init__(self):
    #print("child class constructor")
  def car(self):
    print("child has 50lakh")
son = Child()
son.land()
son.gold()

# If there is same name attribute then obj attribute get higher preference than class attribute,,otherwise class attribute if not mention
class Employee:
  name ="Anonymous"  #class attribute
  def __init__(self): #name
    #self.name = name
    print("Employee created")
  def display(self):
    print("Name:",self.name)

obj = Employee() #"nimo"
obj.display()

"""Decorator--we call a func as an argument in another function."""

def dis(n):
  print("yes Im a decorator")
  n()
def fun():
  print("I am a function")
dis(fun)

def dis(n):
  print("yes Im a decorator")
  n()

@dis
def fun():
  print("I am a function")

#static method --> method that dont use self parameter
class A:
  @staticmethod  # Decorator --> allows us to wrap function in order to change the behavior of the function without modifying it.
  def fun():
    print("Static method")
#obj = A()
#obj.fun()
A.fun()

#class method ,@ classmethod, generally we use when we want to change the class variable,
class Employee:
  company ="cdac"
  def show(self):
    print("company:",self.company)
  @classmethod
  def change_company(cls,new_company):
    cls.company = new_company

e1 =Employee()
e1.show()
e1.change_company("TCS")
e1.show()
print(Employee.company)

"""when we need to use parent class method instead of child class method ---- super() keyword. the super() keyword in python is used to refer parent class.specially useful when a class inherits from multiple parent classes and you want to call a method from one of the parent class.
when a class inherits from a parent class,it can override or extend the  methods defined in the parent class.sometimes we need to use the parent class method in the child class.this is where we will use super() keyword.
"""

class Father:
  def land(self):
    print("Father has 20 Cr property")

class Mother:
  def gold(self):
    print("Mother has 10 Cr worth gold")

class Child(Father,Mother):
  def car(self):
    print("child has 50lakh worth car")
    super().land()
cobj = Child()
cobj.car()

class Father:
  def land(self):
    print("Father has 20 Cr property")
  def car(self):
    print("father owns lamborgini")

class Mother:
  def gold(self):
    print("Mother has 10 Cr worth gold")
  def car(self):
    print("Mother owns Audi")

class Child(Mother,Father):
  def car(self):
    super().car()
    #print("child has 50lakh worth car")

cobj = Child()
cobj.car()

"""if we want to inherit parent class constructor ..Using super() keyword"""

class Father:
  def __init__(self):
    print("father class constructor")
  def land(self):
      print("Father has 20 cr property")
class Mother:
  def __init__(self):
      print("Mother class constructor")
  def gold(self):
     print("Mother has 10 cr property")

class Child(Mother,Father):
  def __init__(self):
    print("child class constructor")
    super().__init__()
  def car(self):
    print("child has 50lakh")

son = Child()

class A:
  def __init__(self,name,age):
    self.name = name
    self.age = age
class B(A):
  def __init__(self,name,age,email):
    super().__init__(name,age) #constructor inheritance
    self.email = email
  def show(self):
    print(self.name,self.age,self.email)
obj = B("ram",25,"ram@gmail.com")
obj.show()

"""Polymorhism : operator overloading --when the same operator is allowed  to have different meaning according to the context. print(1+2) print("ram" +" charan") concate
print([1,2,3]+[2,3,4]) merge
"""

#Polymorphism -->same func name but different behaviour/signature
#method overriding known as Runtime Polymorphisim,  compile time Polymorphism--> method overloading (same parameter but differ signature)
#not found by default,need to achive
#operator overloading 3+6j ,2+4j
class Complex:
  def __init__(self,real,img):
    self.real =real
    self.img = img
  def shownum(self):
    print(self.real,"+",self.img,"j")

  def add(self,num2):
    newreal =self.real +num2.real
    newimg = self.img +num2.img
    return Complex(newreal,newimg)

  def __add__(self,num2):
    newreal =self.real +num2.real
    newimg = self.img +num2.img
    return Complex(newreal,newimg)

num1 = Complex(2,3)
num1.shownum()
num2 = Complex(1,2)
num2.shownum()
#var = obj.add(obj2)
#var.shownum()
#we will try to implement without using add func

#using __add__ dunder method

num3 = num1+num2 #for addintion now we are using + operator
num3.shownum()

#method overriding
class Phone:
  def __init__(self,price,brand,camera):
    print("parent class constructor called")
    self.price = price
    self.brand = brand
    self.camera = camera
  def buy(self):
    print("Buying a phone")
class Smartphn(Phone):
  def buy(self):
    print("Buying a smart phn")

s = Smartphn(200000,"Apple","16")
s.buy()